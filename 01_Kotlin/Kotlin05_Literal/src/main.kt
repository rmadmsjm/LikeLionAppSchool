// 리터럴
// 프로그램이 언어에서 값을 작성하는 문법
// 작성하는 값에 따라서 기억공간의 용도, 크기, 위치가 결정됨

// 용도 : 저장하는 값을 효율적이고 정상적으로 유지하기 위한 방법을 결정함
// 자료구조에서 정의하는 값 관리 기법을 따름 (정수, 실수 등 값의 형태에 따라 관리 방법이 다름)
// 크기 : 리터럴인 경우에는 크기가 정해져 있음
// 위치 : OS가 비어있는 공간의 위치를 알려주기 때문에 알아서 결정됨

fun main() {
    // 정수(4 byte or 8 byte)
    println(100)
    println(2147483647)
    println(-2147483648)
    // 자바의 경우 정수값을 작성하면 4 byte 기억 공간이 마련되기 때문에 범위를 벗어난 겂을 작성하면 오류가 발생함
    // 따라서 8 byte 기억 공간이 만들어질 수 있도록 L을 뒤에 붙여야 함
    println(2147483648L)
    println(-2147483649L)
    // 그런데 Kotlin의 경우 L을 붙이지 않아도 작성된 값을 보고 Java 코드로 변환될 때 4 byte면 충분한 경우 정수값 그대로 유지됨
    // 8 byte 기억 공간이 필요한 값이라면 뒤에 L을 붙인 코드로 변경됨
    // 즉, Kotlin은 정수값을 작성할 때 값의 범위를 보고 뒤에 L을 붙이지 않아도 됨
    println(2147483648)
    println(-2147483649)

    // 정수값을 작성할 때 자리의 구분을 위해 '_'를 사용할 수 있음
    // '_'를 작성해도 그냥 정수값임
    println(123_456_789)

    // 실수 (8 byte)
    println(11.11)
    // 실수 (4 byte)
    println(11.11F)

    // 문자 (2 byte ?, 실행되는 시스템에 따라감)
    // 내부적으로 정수값을 관리됨
    println('A')
    println('가')

    // 문자열 (작성한 글자 수 만큼 메모리를 사용함. 객체라는 것으로 관리됨)
    println("문자열")

    // 논리 타입
    // 참
    println(true)
    // 거짓
    println(false)

    // RawString
    // 여러 줄의 문자열을 표현할 때 사용함
    println("""멈춰버린 회색 구름
        |다 타버려 갈린 검은 땅
        |세상 끝에 몰린 절망
        |터져버린 붉은 심장
    """.trimMargin())
}
